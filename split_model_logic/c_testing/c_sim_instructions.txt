Natalia Mendiola, C Simulation of Distributed Communication C++
2/6/2025

TO RUN:
1.Open two terminals, one for main and the other for Sub

2a. On a terminal, first run :
./c_server

2b. On the other terminal, run the following:
./c_client

3. Using xor_validation.py, copy the respective values of w1, w2, bias1, bias2 from learned_weights_bias.txt 
and check accuracy

---------------------------
TO EDIT:
1. If on windows, please ensure you have mingw-w64 downloaded 
to run C++ files on VScode
https://code.visualstudio.com/docs/cpp/config-mingw

2. If making edits to code, run
g++  test_c_main.cpp act_pe.cpp array.cpp bias_pe.cpp error_pe.cpp weight_pe.cpp -o c_server 
g++  test_c_sub.cpp act_pe.cpp array.cpp bias_pe.cpp error_pe.cpp weight_pe.cpp -o c_client 

note: If #pragma comment(lib, "ws2_32.lib") not present, also use  -lws2_32

3. Open two terminals, one for main and the other for Sub

4. On a terminal, first run :
./desired_main_file_name

On the other terminal, run the following:
./desired_sub_file_name





For C++

How to send stuff:
fixed_16 bias_change[ARRAY_SIZE] = {0, 1};

send(new_socket, reinterpret_cast<char*>(bias_change), sizeof(bias_change), 0);
cout << "Send bias to client" <<endl;


How to receive stuff: 

// Receive acknowledgment from client
ssize_t valread = recv(new_socket, buffer, BUFFER_SIZE, 0);
if (valread > 0) {
    buffer[valread] = '\0';
    cout << "Received acknowledgment: " << buffer << endl;
} else {
    cerr << "Error reading from socket" << endl;
}


how to close socket at end:
cout<<"Ran through all epoch! Sending termination signal"<<endl;

string end_signal = "END";
send(new_socket, end_signal.c_str(),end_signal.size(),0);
cout << "Training complete. Sent termination signal to client." << endl;

// Close the sockets
closesocket(new_socket);
closesocket(server_fd);
WSACleanup();